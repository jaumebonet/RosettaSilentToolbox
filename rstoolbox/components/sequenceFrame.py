# -*- coding: utf-8 -*-
"""
.. codeauthor:: Jaume Bonet <jaume.bonet@gmail.com>

.. affiliation::
    Laboratory of Protein Design and Immunoengineering <lpdi.epfl.ch>
    Bruno Correia <bruno.correia@epfl.ch>

.. class:: SequenceFrame
"""
# Standard Libraries

# External Libraries
import six
import pandas as pd
import numpy as np

# This Library
from .rsbase import RSBaseFrequency
from .selection import get_selection

__all__ = ["SequenceFrame"]


class SequenceFrame( pd.DataFrame, RSBaseFrequency ):
    """Per position frequency occurrence for a set of decoys.

    The :class:`.SequenceFrame` extends :class:`pandas.DataFrame`.
    Ideally, in this :class:`pandas.DataFrame`, each column represents a ResidueType
    (or NucleotideType) and each row a sequence position.

    A ``reference_sequence`` can be provided, but it has to be the exact same
    length as the sequence expressed in the :class:`pandas.DataFrame`.

    As it represents sequence, unless the :class:`.SequenceFrame` is generated by
    slicing another, one should expect the index to start in 1.
    """
    _metadata = ['_reference', '_measure', '_extras', '_delextra', '_delempty']
    _subtyp = 'sequence_frame'

    def __init__(self, *args, **kwargs):
        reference = kwargs.pop('reference', {})
        measure   = kwargs.pop('measure', "")
        super(SequenceFrame, self).__init__(*args, **kwargs)
        self._reference = reference
        self._measure    = measure
        self._extras     = []
        self._delextra   = True
        self._delempty   = -1

    def extras( self, extras=None ):
        """Setter/Getter for the extra amino/nucleic acid names.

        Defines those names that are not regular/natural monomers.

        :param list measure: List of 1 letter names to be considered. By default is
            :py:data:`None`, which turns the function into a getter.

        :return: list
        """
        if extras is not None:
            self._extras = extras
        return self._extras

    def delete_extra( self, pick=None ):
        """Setter/Getter for the delete extra configuration.

        Set the behaviour to decide whether or not non-regular positions
        have to be deleted if empty.

        :param bool pick: Whether or not to activate this option. By default is
            :py:data:`None`, which turns the function into a getter.

        :return: bool
        """
        if pick is not None:
            self._delextra = pick
        return self._delextra

    def delete_empty( self, pick=None ):
        """Setter/Getter for the delete empty configuration.

        Set the behaviour to decide whether or not regular positions
        have to be deleted if empty. This does not apply to amino acid types
        present in the reference_sequence.

        :param int pick: Remove from the SequenceFrame the regular
            amino/nucleic acids if they frequency is equal or under the value . Default is -1,
            so nothing is deleted.

        :return: bool
        """
        if pick is not None:
            self._delempty = pick
        return self._delempty

    def is_transposed( self ):
        """Assert if the :class:`.SequenceFrame` is found as expected (ResidueType
        as column) or transposed.

        :class:`.SequenceFrame`, when created, has each column specify a residue type
        and each row specify a sequence position. When it is the other way around, we assume
        it is transposed.

        :return: :data:`True` if the object is transposed.
        """
        h = list(self)[0]
        if isinstance(h, six.string_types):
            return False
        else:
            return True

    def measure( self, measure=None ):
        """Setter/Getter for the mesurement specification.

        Specifies which type of mesurement the object represents.
        It can be ``frequency`` or ``bits``.

        :param str measure: Measure name. By default is
            :data:`None`, which turns the function into a getter.
        """
        known = ["frequency", "bits"]
        if measure is not None:
            if measure.lower() not in known:
                raise ValueError("Measure type {0} not in {1}".format(measure, ",".join(known)))
            self._measure = measure
        return self._measure

    def get_key_residues( self, key_residues=None ):
        """Get positions of interest.

        Extracts those residues from the :class:`.SequenceFrame` that are really
        necessary

        :param key_residues: |keyres_param|.
        :type key_residues: |keyres_types|
        """
        if key_residues is None:
            return self

        if self.is_transposed():
            return self.transpose().get_key_residues(key_residues).transpose()

        try:
            seqID = self.get_available_references()[0]
            sft = self.get_reference_shift(seqID)
        except IndexError:
            seqID = None
            sft = 1

        kr = get_selection(key_residues, seqID, sft, self.shape[0])
        # by position is -1
        kr = [x - 1 for x in kr]
        return self.iloc[kr]

    def max_hight( self ):
        """
        Calculate the maximum expected value considering the amount of variants.
        If :class:`.SequenceFrame` is of type ``frequency``, it will return 1.

        For type "bits", this is calculated as::

            log2 N

        Where:
            - N is the total number of options (4: DNA/RNA; 20: PROTEIN). This is automatically
              picked from the number of columns, which means that adding/deleting columns for
              different reasons will translate into different maximum expected height.

        :return: float
        """
        if self.measure() == "frequency":
            return 1
        elif self.measure() == "bits":
            return np.log2(self.shape[1])

    def to_bits( self ):
        """
        Change the sequenceFrame from frequency to bits.
        Bit calculation is performed as explained in
        http://www.genome.org/cgi/doi/10.1101/gr.849004::

            Rseq = Smax - Sobs = log2 N - (-sum(n=1,N):pn * log2 pn)

        Where:
            - N is the total number of options (4: DNA/RNA; 20: PROTEIN). This is automatically
              picked from the number of columns, which means that adding/deleting columns for
              different reasons will translate into different maximum expected height.
            - pn is the observed frequency of the symbol n.

        :return: :class:`.SequenceFrame` - with the new scoring system
        """
        def get_position_height( row ):
            def individual_entropy( cell ):
                return np.log2(cell) * cell
            return np.sum(row.apply(lambda cell: individual_entropy(cell)))

        if self.measure() == "bits":
            return self

        df = self.copy(deep=True)
        df.measure("bits")
        df["entropy"] = df.max_hight() + df.apply(lambda row: get_position_height( row ), axis=1)
        aa_columns = [col for col in df.columns if len(col) == 1]
        df = df[aa_columns].multiply(df["entropy"], axis=0)
        df.measure("bits")
        df.transfer_reference(self)
        return df

    def clean( self ):
        """Apply the logic set by clean_extra and clean_empty.

        Modifications are applied "inplace"

        :return: self
        """
        if self.is_transposed():
            return self.transpose().clean().transpose()

        if set(self.extras()).issubset(self.columns):
            if self.delete_extra():
                self.drop(self.extras(), axis=1, inplace=True)

        if self.delete_empty() >= 0:
            s = pd.Series((self <= self.delete_empty()).sum(axis=0) == self.shape[0])
            todel = s[s == True].index.tolist()
            if self._reference != "":
                todel = set(todel).difference(set(list(self._reference)))
            self.drop(todel, axis=1, inplace=True)
        return self

    #
    # Implement pandas methods
    #

    @property
    def _constructor( self ):
        return SequenceFrame
